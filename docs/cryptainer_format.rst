
Encrypted container format
============================

The data recorded by a WitnessAngel device is encrypted and stored into a flexible "cryptainer" format. The idea is to allow each payload (media data, metadata, symmetric and asymmetric keys...) to be encrypted/signed by several entities, one after the other.

A configuration tree, with a structure similar to the cryptainer tree, is used to specify which algorithms and escrows the encryption/signing process must use.
Escrows can be the local filesystem, or USB keys used as authentication devices, or remote webservices...

The final serialization is done using Pymongo's Extended Json dialect; bson might one day be used as an alternative.

Note : to convert base64 UUIDs to a more natural hexadecimal form, use a converter like https://base64.guru/converter/decode/hex

While the `cryptainer_uid` value uniquely identifies the cryptainer, its `keychain_uid` value can be shared by several cryptainers, which thus end up using a common set of keypairs generated by escrows. Note that `keychain_uid` can also be overridden at some levels of the conf tree, for specific escrows.

**Beware, this format is not stable and specified yet.**


Example
---------

A minimal cryptainer configuration in python, with a single encryption layer and its single signature, both backed by the "local" escrow service of the device; this format can't be used in real life of course, since the data is not protected against illegal reads::

    from wacryptolib.cryptainer import LOCAL_ESCROW_MARKER

    CONFIG = dict(
        payload_encryption_layers=[
            dict(
                payload_encryption_algo="AES_CBC",
                key_encryption_layers=[
                    dict(
                        key_encryption_algo="RSA_OAEP",
                        key_encryption_escrow=LOCAL_ESCROW_MARKER,
                    )
                ],
                payload_signatures=[
                    dict(
                        payload_digest_algo="SHA256",
                        payload_signature_algo="DSA_DSS",
                        payload_signature_escrow=LOCAL_ESCROW_MARKER,
                    )
                ],
            )
        ]
    )


The corresponding cryptainer content, in Pymongo's Extended Json format::


  {
      "cryptainer_format": "WA_0.1a",
      "cryptainer_uid": {
          "$binary": {
              "base64": "DlYx92FIAAkm8ncnLoDO4Q==",
              "subType": "03"
          }
      },
      "payload_ciphertext": {
          "$binary": {
              "base64": "eyJjaXBoZXJ0ZXh0IjogeyIkYmluYXJ5IjogeyJiYXNlNjQiOiAibEZFVWw3Qm1aRExXNkZTSDlsaDVrTjVPYkpYQ2RJN0RIWnlxcm9kSktob20rZmEza0JOYzM3K2NKTzBaay9MUnlId3lhSExlK20yclpsMm1tNXJtd24zMGNmNlZYNTdlNlVFcDVKWkc4MXNNcHpsQ2N6UmZBRUpmM1o4ZUFBdXo0UnJ1ZTROYnFmQml3TjkxbnRkaDhjcFRVVnRsVnZoWFc1VGZSdU9ROCtCR284R1EreHkvS1I0WE9QNlJFbkdhR1dXdjJ2bElaT2Flcm42dytqN3lhQnVEWXZESW1oMWNyK0hGSWIwaXZNYz0iLCAic3ViVHlwZSI6ICIwMCJ9fSwgIml2IjogeyIkYmluYXJ5IjogeyJiYXNlNjQiOiAiM280eXAvcG5lamFZRWtkTjlSOXNUUT09IiwgInN1YlR5cGUiOiAiMDAifX19",
              "subType": "00"
          }
      },
      "payload_encryption_layers": [
          {
              "payload_encryption_algo": "AES_CBC",
              "payload_signatures": [
                  {
                      "payload_digest_algo": "SHA256",
                      "payload_signature_algo": "DSA_DSS",
                      "payload_signature_escrow": "_local_",
                      "signature_value": {
                          "digest": {
                              "$binary": {
                                  "base64": "PDVJ2+UXnFsQy4JRisXOJW3cwMyX4PDanVoA6q7+hORZsMN8yK7ndpUqLMQNNFcpWAWFw+gtzCM=",
                                  "subType": "00"
                              }
                          },
                          "timestamp_utc": {
                              "$numberInt": "1576333246"
                          }
                      }
                  }
              ],
              "key_ciphertext": {
                  "$binary": {
                      "base64": "eyJkaWdlc3RfbGlzdCI6IFt7IiRiaW5hcnkiOiB7ImJhc2U2NCI6ICJCOXowVkF4anpKdDhrcGRod1MzcEdieVhZMk9xZ2NjZjMyUWQyYlJPMmNoRkMrZitQUEJFM2hEUVFPbW4wUDF4V1ZjeUFjQi9ueDFYek9kRUJ4QU9JVHlEWEwyTGFPbVpWdmQ4UUt1OW9LMyt2RTBxdFY0WUt1RHZqcmdPUS92aHRnWnRBQmxORjdrME9Rd1dtNXpvM3NEb3drTG5IaUN2YVJ4OHhUd2FNL2w0UUxTNEg2bVFPMGxiZkJISVQ2aTFIT21FV251TkFJVDMrNi9iWnd2aEJRUjlLbG04eVcrUnJTM1NUa1ZGLytCRHhnQjhhU0pka1ZnbnBwenF0UTlmamhETTd4Z2NRSUxlazl2cnl6QVdxOXRuZXl5OW5HODNrSFZkZXZOWlA5Ty81R29HR3ZtUGtGVGVPeng2cFoxYmx3RDlPWlB0YVNRMG5jNU11QVZKVHc9PSIsICJzdWJUeXBlIjogIjAwIn19XX0=",
                      "subType": "00"
                  }
              },
              "key_encryption_layers": [
                  {
                      "key_encryption_algo": "RSA_OAEP",
                      "key_encryption_escrow": "_local_"
                  }
              ]
          }
      ],
      "keychain_uid": {
          "$binary": {
              "base64": "DlYx92FIysgcjOsbL4J+DQ==",
              "subType": "03"
          }
      },
      "metadata": null  // Can include additional information about contained data
  }






.. OBSOLETE STUFFS - TO BE RESPECIFIED LATER

    NOPE not yet - UUID overrides can exist at different levels of cryptainer data, to change the identifier used in transactions with third-party entities.

    WRONG - A global `keychain_uid` value is available to identify all cryptainers related to a single Witness Angel device.

    Root dict:

        {
            payload_ciphertext: <opaque multi-encrypted data bytestring>,
            payload_encryption_layers: <list of Layer objects targeting ciphertext, in order of application>,
            data_uid: <optional uuid of this specific data cryptainer>,
        }

    Layer object:

        {
            signatures: <optional list of Signature objects for the parent ciphertext at this layer of encryption>,

            encryption_algorithm: <encryption type label>,

            key_uid: <optional uuid of this specific encryption layer>,

            # Then we have either:
            key_ciphertext: <opaque multi-encrypted key bytestring>,
            key_encryption_layers: <(optional) list of Layer objects targeting key_ciphertext, in order of application>,
            # or:
            key_encryption_escrow: <Escrow Entity object able to decrypt the parent data/key ciphertext at this layer of encryption>,
        }

    Signature object:

        {
            payload_signature_algorithm: <signature type label>,
            signature_payload: <opaque signature bytestring>,
            payload_signature_escrow: <Escrow Entity object which signed the parent data/key ciphertext>,
            signature_uid: <optional uuid of this specific signature object>,
        }

    Escrow Entity:

        {
            escrow_type: <"standalone", "shared_secret" or other special values>,

            escrow_identity: <Public UUID or list of public UUIDs of escrow(s)>,

            escrow_operation_uid: <optional uuid of this specific escrow operation>,
        }
